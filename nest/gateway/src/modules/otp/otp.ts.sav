import { IAvailableOtpChannel, IOtpOptions } from '../../types/otp';
import { randomInt, randomUUID } from 'node:crypto';
import { EOtpChannelName } from 'types';
import { Redis } from 'ioredis';
import { OtpChannel } from './channels/otp-channel';
import { config } from '@repo/config';
import { EmailOtpChannel } from './channels/email';

export class Otp {
  private channels: OtpChannel[];
  private store: Redis;
  private otpSessionTTL: number;

  constructor(data: {
    channels?: OtpChannel[];
    store: Redis;
    otpSessionTTL?: number;
  }) {
    const {
      channels = [EmailOtpChannel],
      store,
      otpSessionTTL = config.otpSessionTTL,
    } = data;
    this.channels = channels;
    this.store = store;
    this.otpSessionTTL = otpSessionTTL;
  }

  public async send(otpOptions: IOtpOptions) {
    const {
      data,
      channelName,
      template = 'otp',
      templateData,
      token = randomUUID(),
      otpSessionTTL = this.otpSessionTTL,
      availableChannels = null,
    } = otpOptions;
    console.log(
      data,
      channelName,
      template,
      templateData,
      token,
      otpSessionTTL,
      availableChannels,
    );

    // availableChannels ??= [{ channelName, to }];
    // availableChannels = await this.setChannelsAvailability(availableChannels);
    // const channel = this.getChannelByName(channelName);
    // if (!channel) throw new Error(`OTP channel ${channelName} is not defined`);
    // await channel.send({ data, to, template, templateData, token });
    // const storeKey = this.getStoreKey(token);
    // await this.store.set(
    //   storeKey,
    //   JSON.stringify({ data }),
    //   'PX',
    //   otpSessionTTL,
    // );
    // const exactTTL = await this.store.ttl(storeKey);
    // return {
    //   token,
    //   expiresAt: this.ttlToDate(exactTTL),
    //   channelData: {
    //     name: channelName,
    //     to,
    //     template,
    //   },
    // };
  }

  private getChannelByName(channel: EOtpChannelName) {
    return this.channels.find(({ name }) => name === channel);
  }

  private getStoreKey(token: string): string {
    return `otp:${token}`;
  }

  private getBlockKey(to: string): string {
    return `otp-resend-block:${to}`;
  }

  private ttlToDate(ttl: number): null | Date {
    if (ttl <= 0) return null;
    return new Date(Date.now() + ttl * 1000);
  }

  private async isToBlocked(to: string): Promise<null | Date> {
    const key = this.getBlockKey(to);
    const TTL = await this.store.ttl(key);
    if (TTL <= 0) return null;
    return this.ttlToDate(TTL);
  }

  private async setChannelsAvailability(
    availableChannels?: IAvailableOtpChannel[],
  ): Promise<IAvailableOtpChannel[]> {
    for await (const channel of availableChannels) {
      channel.blockedUntil = await this.isToBlocked(channel.to);
    }
    return availableChannels;
  }

  private generateOtpCode(): number {
    return randomInt(100000, 999999);
  }
}
